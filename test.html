<div class="flex flex-col items-center justify-center">
  <div 
    id="timerDisplay"
    class="timer-display flex justify-center items-center mt-16 text-[120px] manrope cursor-text outline-none focus:outline-none select-none"
    contenteditable="true"
  >
    25:00
  </div>
  <p class="mt-4 text-gray-500 text-sm">Click to edit minutes and seconds</p>
</div>

<script>
class TimerInputHandler {
  constructor() {
    this.timerDisplay = document.getElementById('timerDisplay');
    this.minutes = '25';
    this.seconds = '00';
    this.isEditing = false;
    this.cursorPosition = 0; // 0-1: minutes, 3-4: seconds
    
    this.initialize();
  }

  initialize() {
    // Set initial value
    this.updateDisplay();
    
    // Add event listeners
    this.timerDisplay.addEventListener('focus', this.handleFocus.bind(this));
    this.timerDisplay.addEventListener('blur', this.handleBlur.bind(this));
    this.timerDisplay.addEventListener('keydown', this.handleKeyDown.bind(this));
    this.timerDisplay.addEventListener('input', this.handleInput.bind(this));
    this.timerDisplay.addEventListener('click', this.handleClick.bind(this));
    
    // Prevent drag selection
    this.timerDisplay.addEventListener('mousedown', (e) => e.preventDefault());
  }

  updateDisplay() {
    this.timerDisplay.textContent = `${this.padNumber(this.minutes)}:${this.padNumber(this.seconds)}`;
  }

  padNumber(num) {
    return String(num).padStart(2, '0');
  }

  handleFocus() {
    this.isEditing = true;
    this.timerDisplay.classList.add('editing');
    
    // Set initial cursor position to first digit
    this.setCursorPosition(0);
  }

  handleBlur() {
    this.isEditing = false;
    this.timerDisplay.classList.remove('editing');
    this.validateAndFormat();
  }

  handleClick(e) {
    if (!this.isEditing) return;
    
    // Calculate cursor position based on click
    const rect = this.timerDisplay.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const charWidth = rect.width / 5; // 5 characters total
    
    let position;
    if (clickX < charWidth * 2.5) {
      // Clicked in minutes section
      position = clickX < charWidth * 1.5 ? 0 : 1;
    } else {
      // Clicked in seconds section
      position = clickX < charWidth * 3.5 ? 3 : 4;
    }
    
    this.setCursorPosition(position);
  }

  handleKeyDown(e) {
    // Handle arrow key navigation
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      this.moveCursor(-1);
      return;
    }
    
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      this.moveCursor(1);
      return;
    }
    
    // Handle number input
    if (e.key >= '0' && e.key <= '9') {
      e.preventDefault();
      this.handleNumberInput(e.key);
      return;
    }
    
    // Allow backspace/delete
    if (e.key === 'Backspace' || e.key === 'Delete') {
      e.preventDefault();
      this.handleDelete();
      return;
    }
    
    // Allow home/end for quick navigation
    if (e.key === 'Home') {
      e.preventDefault();
      this.setCursorPosition(0);
      return;
    }
    
    if (e.key === 'End') {
      e.preventDefault();
      this.setCursorPosition(4);
      return;
    }
    
    // Allow tab navigation (but prevent default to handle it)
    if (e.key === 'Tab') {
      e.preventDefault();
      this.moveCursor(e.shiftKey ? -1 : 1);
      return;
    }
    
    // Prevent any other key input except control keys
    if (!e.ctrlKey && !e.metaKey && e.key.length === 1) {
      e.preventDefault();
    }
  }

  handleInput(e) {
    // Prevent any direct text input (we handle everything in keydown)
    e.preventDefault();
  }

  handleNumberInput(number) {
    const positions = this.getCurrentPositions();
    
    // Update the value at current cursor position
    if (this.cursorPosition >= 0 && this.cursorPosition <= 1) {
      // Editing minutes
      const newMinutes = this.updateDigit(this.minutes, this.cursorPosition, number);
      this.minutes = newMinutes;
      this.updateDisplay();
    } else if (this.cursorPosition >= 3 && this.cursorPosition <= 4) {
      // Editing seconds (adjust for colon)
      const pos = this.cursorPosition - 3;
      const newSeconds = this.updateDigit(this.seconds, pos, number);
      this.seconds = newSeconds;
      this.updateDisplay();
    }
    
    // Move cursor to next position automatically
    this.moveCursor(1);
  }

  handleDelete() {
    // Replace current digit with 0
    if (this.cursorPosition >= 0 && this.cursorPosition <= 1) {
      const pos = this.cursorPosition;
      const minutesArray = this.minutes.padStart(2, '0').split('');
      minutesArray[pos] = '0';
      this.minutes = minutesArray.join('');
    } else if (this.cursorPosition >= 3 && this.cursorPosition <= 4) {
      const pos = this.cursorPosition - 3;
      const secondsArray = this.seconds.padStart(2, '0').split('');
      secondsArray[pos] = '0';
      this.seconds = secondsArray.join('');
    }
    
    this.updateDisplay();
    this.setCursorPosition(this.cursorPosition); // Refresh cursor position
  }

  updateDigit(value, position, newDigit) {
    const valueStr = value.padStart(2, '0');
    const array = valueStr.split('');
    array[position] = newDigit;
    return array.join('');
  }

  moveCursor(direction) {
    let newPosition = this.cursorPosition + direction;
    
    // Skip over the colon position (2)
    if (newPosition === 2) {
      newPosition += direction;
    }
    
    // Bound checking
    if (newPosition >= 0 && newPosition <= 4) {
      this.setCursorPosition(newPosition);
    }
  }

  setCursorPosition(position) {
    this.cursorPosition = position;
    
    // We need to use a timeout to ensure the DOM is updated
    setTimeout(() => {
      const range = document.createRange();
      const selection = window.getSelection();
      
      // Get text node
      const textNode = this.timerDisplay.childNodes[0] || this.timerDisplay;
      
      // Set cursor at the correct position
      // Adjust position for display (colon is at position 2)
      let targetPosition = position;
      if (position >= 3) {
        targetPosition += 1; // Account for colon
      }
      
      // Clamp position to valid range
      targetPosition = Math.min(Math.max(targetPosition, 0), this.timerDisplay.textContent.length - 1);
      
      range.setStart(textNode, targetPosition);
      range.setEnd(textNode, targetPosition);
      range.collapse(true);
      
      selection.removeAllRanges();
      selection.addRange(range);
    }, 0);
  }

  getCurrentPositions() {
    return {
      minutes: {
        tens: this.minutes.length >= 2 ? this.minutes[0] : '0',
        ones: this.minutes.length >= 1 ? this.minutes[this.minutes.length - 1] : '0'
      },
      seconds: {
        tens: this.seconds.length >= 2 ? this.seconds[0] : '0',
        ones: this.seconds.length >= 1 ? this.seconds[this.seconds.length - 1] : '0'
      }
    };
  }

  validateAndFormat() {
    // Parse values
    let minutes = parseInt(this.minutes) || 0;
    let seconds = parseInt(this.seconds) || 0;
    
    // Handle overflow
    if (seconds >= 60) {
      minutes += Math.floor(seconds / 60);
      seconds = seconds % 60;
    }
    
    // Cap values
    minutes = Math.min(minutes, 99);
    seconds = Math.min(seconds, 59);
    
    // Update values
    this.minutes = String(minutes);
    this.seconds = String(seconds);
    
    // Ensure two-digit format
    this.updateDisplay();
  }

  // Public method to get the current time
  getTime() {
    return {
      minutes: parseInt(this.minutes),
      seconds: parseInt(this.seconds),
      formatted: `${this.padNumber(this.minutes)}:${this.padNumber(this.seconds)}`
    };
  }
}

// Initialize the timer input handler when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const timerHandler = new TimerInputHandler();
  
  // Example: Get current time
  // console.log(timerHandler.getTime());
});
</script>

<style>
.timer-display {
  caret-color: transparent; /* Hide default caret since we manage cursor position */
  min-width: 300px;
  text-align: center;
  letter-spacing: 8px;
  position: relative;
}

.timer-display:focus {
  background-color: rgba(59, 130, 246, 0.05);
  border-radius: 8px;
}

.timer-display:focus-visible {
  outline: none;
}

.timer-display.editing {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}

/* Create custom cursor */
.timer-display.editing::after {
  content: '';
  position: absolute;
  width: 3px;
  height: 80px;
  background-color: #3b82f6;
  animation: blink 1s infinite;
  pointer-events: none;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

/* Position the custom cursor based on current digit */
.timer-display[data-cursor-pos="0"]::after { left: calc(12.5% - 1.5px); }
.timer-display[data-cursor-pos="1"]::after { left: calc(37.5% - 1.5px); }
.timer-display[data-cursor-pos="3"]::after { left: calc(62.5% - 1.5px); }
.timer-display[data-cursor-pos="4"]::after { left: calc(87.5% - 1.5px); }
</style>